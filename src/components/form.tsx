// Generated by simple:form

import {
	Input as InputBase,
	type InputProps as InputBaseProps,
	inputClasses,
} from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
	RadioGroup as RadioGroupBase,
	RadioGroupItem,
} from "@/components/ui/radio-group";
import type { Lang } from "@/lib/i18n/ui";
import { useClientTranslations } from "@/lib/i18n/utils";
import { cn, formatNumber } from "@/lib/utils";
import { CircleDashed, Medal } from "lucide-react";
import React, {
	type ComponentProps,
	createContext,
	useContext,
	useState,
} from "react";
import {
	type FieldErrors,
	type FormState,
	type FormValidator,
	formNameInputProps,
	getInitialFormState,
	toSetValidationErrors,
	toTrackAstroSubmitStatus,
	toValidateField,
	validateForm,
} from "simple:form";

export function useCreateFormContext(
	validator: FormValidator,
	fieldErrors?: FieldErrors,
) {
	const initial = getInitialFormState({ validator, fieldErrors });
	const [formState, setFormState] = useState<FormState>(initial);
	return {
		value: formState,
		set: setFormState,
		setValidationErrors: toSetValidationErrors(setFormState),
		validateField: toValidateField(setFormState),
		trackAstroSubmitStatus: toTrackAstroSubmitStatus(setFormState),
	};
}

export function useFormContext() {
	const formContext = useContext(FormContext);
	if (!formContext) {
		throw new Error(
			"Form context not found. `useFormContext()` should only be called from children of a <Form> component.",
		);
	}
	return formContext;
}

type FormContextType = ReturnType<typeof useCreateFormContext>;

const FormContext = createContext<FormContextType | undefined>(undefined);

export function Form({
	children,
	validator,
	context,
	fieldErrors,
	name,
	...formProps
}: {
	validator: FormValidator;
	context?: FormContextType;
	fieldErrors?: FieldErrors;
} & Omit<ComponentProps<"form">, "method" | "onSubmit">) {
	const formContext = context ?? useCreateFormContext(validator, fieldErrors);

	return (
		<FormContext.Provider value={formContext}>
			<form
				{...formProps}
				method="POST"
				onSubmit={async (e) => {
					const formData = new FormData(e.currentTarget);
					formContext.set((formState) => ({
						...formState,
						isSubmitPending: true,
						submitStatus: "validating",
					}));
					const parsed = await validateForm({ formData, validator });
					if (parsed.data) {
						return formContext.trackAstroSubmitStatus();
					}

					e.preventDefault();
					e.stopPropagation();
					formContext.setValidationErrors(parsed.fieldErrors);
				}}
			>
				{name ? <input {...formNameInputProps} value={name} /> : null}
				{children}
			</form>
		</FormContext.Provider>
	);
}

type InputProps = InputBaseProps & { name: string };
export function Input({ onBlur, onChange, ...inputProps }: InputProps) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[inputProps.name];
	if (!fieldState) {
		throw new Error(
			`Input "${inputProps.name}" not found in form. Did you use the <Form> component?`,
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;
	return (
		<>
			<InputBase
				onBlur={async (e) => {
					onBlur?.(e);
					const value = e.target.value;
					if (value === "") return;
					formContext.validateField(inputProps.name, value, validator);
				}}
				onChange={async (e) => {
					onChange?.(e);
					if (!hasErroredOnce) return;
					const value = e.target.value;
					formContext.validateField(inputProps.name, value, validator);
				}}
				{...inputProps}
			/>
			{validationErrors?.map((e) => (
				<p className="text-destructive text-sm font-medium mt-1" key={e}>
					{e}
				</p>
			))}
		</>
	);
}

type CurrencyInputProps = InputProps;
export function CurrencyInput({
	defaultValue,
	onBlur,
	onChange,
	...inputProps
}: CurrencyInputProps) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[inputProps.name];
	if (!fieldState) {
		throw new Error(
			`Input "${inputProps.name}" not found in form. Did you use the <Form> component?`,
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<InputBase
				onBlur={async (e) => {
					onBlur?.(e);
					const value = e.target.value;
					if (value === "") return;
					formContext.validateField(inputProps.name, value, validator);
				}}
				onChange={async (e) => {
					onChange?.(e);
					e.target.value = formatNumber(e.target.value.replace(/[^0-9]/g, ""));
					const value = e.target.value;
					if (!hasErroredOnce) return;
					formContext.validateField(inputProps.name, value, validator);
				}}
				inputMode="decimal"
				defaultValue={
					defaultValue ? formatNumber(String(defaultValue)) : undefined
				}
				{...inputProps}
			/>
			{validationErrors?.map((e) => (
				<p className="text-destructive text-sm font-medium mt-1" key={e}>
					{e}
				</p>
			))}
		</>
	);
}

type SelectProps = ComponentProps<"select"> & {
	name: string;
	options: { name: React.ReactNode; id: string }[];
};
export function Select({ className, options, ...selectProps }: SelectProps) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[selectProps.name];
	if (!fieldState) {
		throw new Error(
			`Input "${selectProps.name}" not found in form. Did you use the <Form> component?`,
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<select
				className={cn(inputClasses, className)}
				onBlur={async (e) => {
					const value = e.target.value;
					if (value === "") return;
					formContext.validateField(selectProps.name, value, validator);
				}}
				onChange={async (e) => {
					const value = e.target.value;
					if (!hasErroredOnce) return;
					formContext.validateField(selectProps.name, value, validator);
				}}
				{...selectProps}
			>
				{options.map(({ name, id }) => (
					<option key={id} value={id}>
						{name}
					</option>
				))}
			</select>

			{validationErrors?.map((e) => (
				<p className="text-destructive text-sm font-medium mt-1" key={e}>
					{e}
				</p>
			))}
		</>
	);
}

type RadioGroupProps = ComponentProps<typeof RadioGroupBase> & {
	name: string;
	options: { name: React.ReactNode; id: string }[];
	defaultValue?: string;
};
export function RadioGroup({
	className,
	options,
	...radioGroupProps
}: RadioGroupProps) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[radioGroupProps.name];
	if (!fieldState) {
		throw new Error(
			`Input "${radioGroupProps.name}" not found in form. Did you use the <Form> component?`,
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<RadioGroupBase
				onValueChange={async (value) => {
					if (!hasErroredOnce) return;
					formContext.validateField(radioGroupProps.name, value, validator);
				}}
				{...radioGroupProps}
			>
				{options.map(({ name, id }) => (
					<div className="flex items-center space-x-2" key={id}>
						<RadioGroupItem value={id} id={id} />
						<Label htmlFor={id}>{name}</Label>
					</div>
				))}
			</RadioGroupBase>

			{validationErrors?.map((e) => (
				<p className="text-destructive text-sm font-medium mt-1" key={e}>
					{e}
				</p>
			))}
		</>
	);
}

type SavingProps = ComponentProps<"p">;
export function Saving({ className, ...props }: SavingProps) {
	const t = useClientTranslations();
	const { value } = useFormContext();

	return value.submitStatus === "submitting" ? (
		<p className={cn("flex items-center font-semibold", className)} {...props}>
			<CircleDashed className="w-4 h-4 animate-spin mr-2" />
			{t("saving")}
		</p>
	) : null;
}

type SuccessProps = ComponentProps<"p"> & { lang?: Lang };
export function Success({ className, lang, ...props }: SuccessProps) {
	const t = useClientTranslations(lang);
	return (
		<p
			className={cn(
				"flex items-center font-semibold px-4 py-2 bg-green-50 text-green-800 border-green-800 border rounded-md",
				className,
			)}
			{...props}
		>
			<Medal className="w-4 h-4 mr-2" />
			{t("saved")}
		</p>
	);
}
